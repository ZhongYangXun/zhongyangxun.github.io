<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>zhongyangxun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="zhongyangxun">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="zhongyangxun">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhongyangxun">
  
    <link rel="alternative" href="/atom.xml" title="zhongyangxun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="./images/head.jpg" class="js-avatar show">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">菲利普马洛</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/ZhongYangXun" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/5321847680/" title="weibo">weibo</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">菲利普马洛</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="./images/head.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">菲利普马洛</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/ZhongYangXun" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/5321847680/" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-JavaScript作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/31/JavaScript作用域/">JavaScript 作用域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>作用域和变量有关，先看简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'a'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="string">'b'</span></div><div class="line">  <span class="built_in">console</span>.log(a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo() <span class="comment">// 'a'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></div></pre></td></tr></table></figure>
<p>从上面代码的执行结果可以看出，<code>foo</code> 函数取到了它外部的变量 <code>a</code>, 而最外层的 <code>console.log(b)</code> 操作并没能取得 <code>foo</code> 函数里面的变量 <code>b</code>.</p>
<p>上面代码中，最外层的变量对象保存了变量 <code>a</code> 以及函数 <code>foo</code>，代码执行所需的变量和函数都从变量对象里面取得。 变量对象和当前的执行环境相关联，当前执行环境的代码执行结束后，该环境被丢弃，其中保存的变量和函数也随之被丢弃。</p>
<p>每个函数都拥有自己的执行环境，当函数执行时，执行环境被拾起，函数执行完毕，执行环境被丢弃。</p>
<p>上面代码最外层的 <code>console.log(b)</code> 试图取一个变量 <code>b</code>, 但是当前的变量对象，也就是最外层的变量对象，并没有保存变量 <code>b</code>, 所以代码报错。</p>
<p>而 <code>foo</code> 为什么能够取到外部的变量 <code>a</code> 呢？</p>
<p>分析一下 <code>foo</code> 取得 <code>a</code> 的过程。</p>
<p>当 <code>foo</code> 执行的时候， <code>JavaScript</code> 创建了一个活动对象。函数的活动对象是在函数执行时产生的，包含了函数的形参和函数内声明的变量等。 <code>foo</code> 声明的 <code>b</code> 在就 <code>foo</code> 的活动对象里面。在函数的执行环境中，活动对象被当做变量对象。</p>
<p>可是，<code>foo</code> 需要的是 <code>a</code> 啊，<code>foo</code> 自身的变量对象没有这个变量。</p>
<p>不要着急，在创建 <code>foo</code> 的时候，也创建了作用域链，里面包含了外一层的变量对象，保存在函数的 <code>[[Scope]]</code> 属性当中。</p>
<p>在调用 <code>foo</code> 的时候，创建 <code>foo</code> 的执行环境和活动对象，然后复制 <code>[[Scope]]</code> 属性构建作用域链，再把当前活动对象插队放到作用域链的最前面。这个时候，<code>foo</code> 自身的活动对象和外部的变量对象就在这个作用域里面排队。</p>
<p>当 <code>foo</code> 在作用域链的最前面，也就是自身的活动对象里面，找不到变量 <code>b</code> 的时候，就会去作用域链的下一个对象里面查找。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>作用域链依次保存了当前执行环境的变量对象，以及外层执行环境的变量对象。就像是变量对象在排队，越是内层的变量对象，越在前面。若无法在当前的变量对象找到一个变量，就会顺着作用域链，依次查找外部的变量对象。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包，看着这两个字，顾名思义也思不出什么来，不如先把它从脑中先抛开。</p>
<h3 id="举个栗子-1"><a href="#举个栗子-1" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>从文章的第一个例子，可以知道，在函数的外部是访问不了函数内部的变量的。</p>
<p>简单粗暴地去访问，当然访问不了，但也可以通过一系列操作，来访问函数内部变量。</p>
<p>看看简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a++)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fn = bar()</div><div class="line"></div><div class="line">fn() <span class="comment">// 0</span></div><div class="line">fn() <span class="comment">// 1</span></div><div class="line">fn() <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>上面的 <code>bar</code> 定义变量 <code>a</code> 为 <code>0</code>, 并函数返回一个函数，返回的函数打印变量 <code>a</code>， 然后对变量 <code>a</code> 进行递增操作。</p>
<p>执行 <code>bar</code> ，并将返回的函数赋值给 <code>fn</code>. 执行 <code>fn</code>, 从执行结果可以看出，这个全局变量的 <code>fn</code> 居然访问到了 <code>bar</code> 内的变量 <code>a</code>.</p>
<p>现在去采访一下 <code>fn</code>, 看看他是怎么做到的。</p>
<p><code>fn</code> 的值是 <code>bar</code> 函数的返回值，也就是 <code>bar</code> 里面返回的匿名函数。</p>
<p>当匿名函数被创建的时候，和所有函数一样，也是将外部的变量对象保存到自身的 <code>[[Scope]]</code> 属性当中，匿名函数保存的，自然是 <code>bar</code> 的活动对象，里面包含了变量 <code>b</code>.</p>
<p>现在慢动作回放一下 <code>var fn = bar()</code> 这个操作：</p>
<ol>
<li>初始化 <code>bar</code> 的活动对象 ，将 <code>a</code> 保存到活动对象</li>
<li>执行 <code>bar</code>  内代码，给 <code>a</code> 赋值为 <code>0</code></li>
<li>执行 <code>bar</code>  内代码，创建匿名函数，将 <code>bar</code> 的活动对象保存到匿名函数 <code>[[Scope]]</code> 属性</li>
<li><code>bar</code> 返回匿名函数，<code>bar</code> 执行完毕，其执行环境被丢弃</li>
<li><code>fn</code> 接受 <code>bar</code> 返回的匿名函数</li>
</ol>
<p>注意到步骤 4, 虽然 <code>bar</code> 的执行环境被丢弃，但是 <code>bar</code>的活动对象依然在内存中，因为匿名的 <code>[[Scope]]</code> 属性还在引用这个活动对象，而匿名函数赋值给了 <code>fn</code>,  <code>fn</code> 仍然存在于内存中。</p>
<p>执行 <code>fn</code>, <code>fn</code> 自身的活动对象并没有变量 <code>a</code>, 所以顺着作用域链查找 <code>a</code>, 可在 <code>bar</code>  遗留的活动对象中找到。</p>
<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>重新捡起闭包这两个字，《JavaScript 高级程序设计》这样定义闭包：</p>
<blockquote>
<p>闭包是有权访问另一个函数作用域中变量的函数。</p>
</blockquote>
<p>结合上面的例子，可以知道 <code>fn</code> 就是一个闭包，因为它有权访问另一个作用域 <code>bar</code> 内的变量。</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="举个栗子-2"><a href="#举个栗子-2" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>看简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</div><div class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="number">200</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 200</span></div></pre></td></tr></table></figure>
<p>上面的代码输出了 <code>200</code>, 可不要被 <code>for</code> 和 <code>if</code> 的花括号施了障眼法，误以为输出结果是 <code>undefined</code>.</p>
<p>上面的 <code>for</code> 和 <code>if</code> 用花括号包起来的代码块，并没与自己的执行环境，所以上面的代码只有一个全局的执行环境，变量都保存在全局的变量对象里面。这就解释了外层为什么能访问花裤号内部的变量。</p>
<h3 id="再举个栗子"><a href="#再举个栗子" class="headerlink" title="再举个栗子"></a>再举个栗子</h3><p>看简单的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</div><div class="line">  <span class="keyword">if</span> (i === <span class="number">2</span>) &#123;</div><div class="line">    <span class="keyword">const</span> b = <span class="number">200</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></div></pre></td></tr></table></figure>
<p><code>ES6</code> 中的 <code>let</code> 和 <code>const</code> 能够形成块级作用域，用 <code>let</code> 和 <code>const</code> 声明的变量，只能在花括号内部访问。</p>
<h3 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h3><p>简单地用花括号包起来的代码块，是没有自己的执行环境，形成不了作用域的。而 <code>let</code> 和 <code>const</code> 命令声明的变量，只能在花括号内部访问。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作用域和执行环境有关，函数拥有自己的执行环境，创建活动对象，作为自己的变量对象，就形成了作用域。</p>
<p>而简单的用花括号包起来的代码，没有自己的执行环境，当然也形成不了作用域，但是 <code>let</code> 和 <code>const</code> 命令声明的变量，只能在花括号内部访问。</p>
<p>作用域链将内部执行环境的变量对象与外部的变量对象依次保存，使得内部可以访问外部的变量。</p>
<p>当函数 <code>a</code> 的活动对象被函数外的另一个函数 <code>b</code> 引用，函数 <code>b</code> 就是闭包，可以访问函数 <code>a</code> 内的变量。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/08/31/JavaScript作用域/" class="archive-article-date">
  	<time datetime="2019-08-31T03:31:03.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-08-31</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/作用域/">作用域</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript-简单粗暴浅拷贝-钻牛角尖深拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/JavaScript-简单粗暴浅拷贝-钻牛角尖深拷贝/">JavaScript:简单粗暴浅拷贝,钻牛角尖深拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>深拷贝和浅拷贝都和对象的复制有关，它们是对象复制的两种不同方式。接下来就来看一下，浅拷贝是怎么个浅法，还有深拷贝深在哪里。</p>
<h2 id="简单粗暴浅拷贝"><a href="#简单粗暴浅拷贝" class="headerlink" title="简单粗暴浅拷贝"></a>简单粗暴浅拷贝</h2><h3 id="来个栗子"><a href="#来个栗子" class="headerlink" title="来个栗子"></a>来个栗子</h3><p>先复制一个对象看看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'a'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">99</span>,</div><div class="line">  <span class="attr">car</span>: &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'blue'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = &#123;&#125;</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.keys(a).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">  b[key] = a[key]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'a',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'blue'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>首先声明了一个对象 <code>a</code> 还有一个空对象 <code>b</code>. 然后遍历对象 <code>a</code> 的可枚举属性，将属性和属性值一一分配给 <code>b</code>. 这里，实现了对象的复制。</p>
<p>接下来，对 <code>b</code> 进行一些操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">b.name = <span class="string">'b'</span></div><div class="line">b.car.color = <span class="string">'red'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'b',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'red'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'a',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'red'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码，将 <code>b</code> 的 <code>name</code> 属性值变成 <code>&#39;b&#39;</code>, 然后再将 <code>b</code> 的 <code>car</code> 属性的 <code>color</code> 变为 <code>&#39;red&#39;</code>.</p>
<p>打印 <code>b</code>，发现这些改动都预期发生了。</p>
<p>打印 <code>a</code>, 出现了一些意料之外的事情。<code>a</code> 的 <code>name</code> 仍然是 <code>&#39;a&#39;</code> ，然而 <code>a</code> 的 <code>car</code> 属性的 <code>color</code> 属性却发生了变化，变得和刚刚赋给 <code>b</code> 的一样了，成了 <code>&#39;red&#39;</code>.</p>
<p>这是怎么回事呢？</p>
<h3 id="剧情解析"><a href="#剧情解析" class="headerlink" title="剧情解析"></a>剧情解析</h3><p>时光稍微倒流一下，回到复制对象的地方看一看。复制的关键代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.keys(a).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">  b[key] = a[key]</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>代码把 <code>a</code> 的可枚举属性悉数分配给 <code>b</code>.</p>
<p>分配 <code>car</code> 属性的时候，慢动作细节即为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b[<span class="string">'car'</span>] = a[<span class="string">'car'</span>]</div></pre></td></tr></table></figure>
<p><code>a[&#39;car&#39;]</code> 的值是一个对象，准确地说，<code>a[&#39;car&#39;]</code> 的值是一个指针，指向了对象 <code>{color: &#39;blue&#39;}</code> 。</p>
<p>在 JavaScript 当中，把对象赋给一个值，实际上是把对象的内存地址赋给这个值，然后，这个值就指向了该对象。对象是引用类型，不同于基本类型，引用类型存放在堆中。</p>
<p>当把 <code>a[&#39;car&#39;]</code> 的值赋给 <code>b[&#39;car&#39;]</code> 之时，其实是把这个指针复制了一份，然后赋给 <code>b[&#39;car&#39;]</code>，最终， <code>b[&#39;car&#39;]</code> 也指向了同一个对象。</p>
<p>后来执行 <code>b.car.color</code> 对 <code>b.car</code> 指向的对象进行操作，<code>a.car</code> 也产生了变化，因为它们指向的就是同一个对象。</p>
<p>上面这个例子，就属于浅拷贝。</p>
<h3 id="归纳一下"><a href="#归纳一下" class="headerlink" title="归纳一下"></a>归纳一下</h3><p><strong>浅拷贝，简单粗暴，只管复制，不考虑属性值是不是指向对象</strong>。</p>
<p>可能上面这个归纳，在这个时候，还是有点模糊，感觉不甚清晰，接下来，来个深拷贝对比一下。</p>
<h2 id="钻牛角尖深拷贝"><a href="#钻牛角尖深拷贝" class="headerlink" title="钻牛角尖深拷贝"></a>钻牛角尖深拷贝</h2><h3 id="来个栗子-1"><a href="#来个栗子-1" class="headerlink" title="来个栗子"></a>来个栗子</h3><p>先上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">target, source</span>) </span>&#123;</div><div class="line">  <span class="built_in">Object</span>.keys(source).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (getType(source[key]) === <span class="string">'Object'</span>) &#123;</div><div class="line">      target[key] = &#123;&#125;</div><div class="line">      deepCopy(target[key], source[key])</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getType(source[key]) === <span class="string">'Array'</span>) &#123;</div><div class="line">      target[key] = []</div><div class="line">      deepCopy(target[key], source[key])</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      target[key] = source[key]</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> target</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Get type of parameter val.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> reg = <span class="regexp">/^\[object\s(\w*)\]$/</span></div><div class="line">  <span class="keyword">return</span> reg.exec(<span class="built_in">Object</span>.prototype.toString.call(val))[<span class="number">1</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'a'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">99</span>,</div><div class="line">  <span class="attr">car</span>: &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'blue'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> b = &#123;&#125;</div><div class="line"></div><div class="line">deepCopy(b, a)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'a',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'blue'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>上面的代码实现了一个深拷贝函数 <code>deepCopy</code>. 这个函数接受两个参数，<code>target</code> 是目标对象，<code>source</code> 是源对象，函数内将源对象的属性悉数拷贝到目标对象。</p>
<p>函数中首先遍历源对象的属性，分三种情况来处理，分别是当属性值指向对象，指向数组，或者是其他情况。</p>
<p>第一种情况，当 <code>source[key]</code> 指向对象时，先赋一个空对象给 <code>target[key]</code>，然后再以 <code>target[key]</code> 这个空对象为 <code>target</code>  参数，以 <code>source[key]</code> 为 <code>source</code> 参数，递归调用 <code>deepCopy</code>.</p>
<p>第二种情况，当 <code>source[key]</code>指向数组，就赋一个空数组给 <code>target[key]</code>，接下来以 <code>target[key]</code> 作为 <code>target</code> 参数，以 <code>source[key]</code>  为 <code>source</code> 参数，递归调用 <code>deepCopy</code>.</p>
<p>第三种情况，当 <code>source[key]</code> 不是对象也不是数组，那么直接把 <code>source[key]</code> 的值赋给 <code>target[key]</code>.</p>
<p>遍历结束，<code>deepCopy</code> 返回 <code>target</code>.</p>
<p>接着，声明了函数 <code>getType</code>, 就是 <code>deepCopy</code> 里面用到的判断数据类型的函数。<code>getType</code> 接受一个参数 <code>val</code>, 并返回 <code>val</code> 的类型。函数内利用 <code>Object.prototype.toString</code> 得到 <code>val</code> 的类型，但这样得到的是类似 <code>&#39;[object String]&#39;</code>以及 <code>&#39;[object Array]&#39;</code> 这样的字符串，还需要加工一下，才能拿到代表类型的字符串，所以声明了一个正则表达式，来进行从 <code>&#39;[object String]&#39;</code> 提取出 <code>&#39;String&#39;</code> 这样的工作。</p>
<p>然后，声明对象 <code>a</code>, 接着，声明空对象 <code>b</code>, 再执行 <code>deepCopy(b, a)</code> 将 <code>a</code> 深拷贝到 <code>b</code>.</p>
<p><code>console.log(b)</code> 可知 <code>b</code> 已经成功拿到 <code>a</code> 的可枚举属性。</p>
<p>接下来，对 <code>b</code> 进行一些操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">b.name = <span class="string">'b'</span></div><div class="line">b.car.color = <span class="string">'red'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(b)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'b',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'red'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a)</div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//   name: 'a',</span></div><div class="line"><span class="comment">//   age: 99,</span></div><div class="line"><span class="comment">//   car: &#123;</span></div><div class="line"><span class="comment">//     color: 'blue'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<p>像第一个例子一样，将 <code>b</code> 的 <code>name</code> 属性赋值为 <code>&#39;b&#39;</code>, <code>b</code> 的 <code>car</code> 属性的 <code>color</code> 赋值为 <code>&#39;red&#39;</code>.</p>
<p>打印 <code>b</code>, 发现改变已经生效。</p>
<p>打印 <code>a</code>, 可见 <code>a</code> 没有像上一个例子那样发生改变。</p>
<h3 id="剧情解析-1"><a href="#剧情解析-1" class="headerlink" title="剧情解析"></a>剧情解析</h3><p>在这个例子中，当遍历到 <code>a[car]</code> 属性的时候，发现属性值指向的是一个对象，就将一个空对象赋给 <code>b[car]</code>, 再把 <code>a[car]</code> 所指向的对象当做 <code>source</code>, <code>b[car]</code> 指向的空对象当做 <code>target</code>, 执行 <code>deepCopy</code> 操作，将 <code>a[car]</code> 所指的对象属性拷贝给 <code>b[car]</code> 所指的空对象。这个时候， <code>a[car]</code> 和 <code>b[car]</code> 所指的并非同一个对象，所以，任凭怎么操作 <code>b[car]</code>, <code>a[car]</code> 都不会受到丝毫影响。</p>
<h3 id="归纳一下-1"><a href="#归纳一下-1" class="headerlink" title="归纳一下"></a>归纳一下</h3><p>这就是深拷贝，深拷贝在遍历源对象属性的时候，<strong>遇到可遍历的，如对象和数组，会再深入遍历其属性，并进行拷贝</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的例子可以知道，深拷贝和浅拷贝，区别在于，在遍历源对象的时候，遇到可遍历的属性值，会不会去进行遍历。浅拷贝是直接将属性值复制过去，而深拷贝则会继续深入遍历并拷贝。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/26/JavaScript-简单粗暴浅拷贝-钻牛角尖深拷贝/" class="archive-article-date">
  	<time datetime="2019-07-26T13:49:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-26</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript事件代理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/JavaScript事件代理/">JavaScript 事件代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“代理”可以理解为代劳或者帮忙，或者类似你的事就是我的事这种乐于助人的良好品质。JavaScript 也有许多事件要处理，接着就演示下，如何在 DOM 元素中选出一位热心肠的好同学。  </p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>想象一个平平无奇的表格，像下面这样：</p>
<p><img src="/images/javascript-event-proxy/table.PNG" alt=""></p>
<p>需求是点击删除按钮可删除单条数据。</p>
<p>用 JavaScript 实现点击删除的操作，需要监听按钮点击事件，在事件点击回调中，发送删除数据的请求，请求成功后重新渲染表格。</p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>基本款的实现大概如下：</p>
<p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>汉堡<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-id</span>=<span class="string">"1"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">...</div></pre></td></tr></table></figure>
<p>JavaScript:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> deleteItem = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</div><div class="line">  <span class="comment">// 依据 ID 删除数据。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> btnList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'btn'</span>)</div><div class="line"><span class="built_in">Array</span>.prototype.forEach.call(btnList, (btn) =&gt; &#123;</div><div class="line">  btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    deleteItem(<span class="keyword">this</span>.dataset.id)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的代码给每一条删除按钮都添加了点击事件的回调。上面的代码利用自定义属性 <code>data-id</code> 将单条数据的 <code>ID</code> 传给数据的删除按钮，然后在点击事件的回调中通过 <code>dataset</code> 属性取得，将其传递给处理删除的函数。</p>
<p>这样可以实现上面的上面所说的删除功能。</p>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>可是这么写，当数据一多，将会对页面性能造成影响。</p>
<p>参考《JavaScript 高级程序设计》：</p>
<blockquote>
<p>首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。其次，必须事先指定所有事件处理程序而导致的 DOM 访问次数，会延迟整个页面的交互就绪时间。</p>
</blockquote>
<p>面对这种状况，解决方案是事件代理。</p>
<h2 id="事件代理实现"><a href="#事件代理实现" class="headerlink" title="事件代理实现"></a>事件代理实现</h2><p>先看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>)</div><div class="line">table.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (e.target.tagName === <span class="string">'BUTTON'</span>) &#123;</div><div class="line">    deleteItem(e.target.dataset.id)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>上面的代码，首先在回调中通过事件对象 <code>e</code> 的 <code>target</code> 属性取得触发点击事件的元素，然后通过 <code>tagName</code> 判断这个元素是不是按钮，如果是的话，就进行删除操作。</p>
<p>只添加了一次事件处理函数，就实现了功能。</p>
<p>这里利用的是事件流的事件冒泡。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流有三个阶段，分别是事件捕获阶段，处于目标阶段，还有事件冒泡阶段。</p>
<p>按钮点击事件的事件流如下：</p>
<p><img src="/images/javascript-event-proxy/event-flow.png" alt=""></p>
<p>上图省略了 <code>tr</code> ,<code>td</code>, <code>tbody</code>    这些元素，只用关键的元素来展示事件流。</p>
<p>“事件捕获”是不太精确的目标先接收到事件，首先是文档，然后再到 <code>body</code>，逐渐精确到最具体的节点 <code>button</code>.</p>
<p>当 <code>button</code> 接收到事件，即为“处于目标阶段”。</p>
<p>之后，事件再向外层逐级传播到不太具体的节点，这便是“事件冒泡阶段”。</p>
<h3 id="冒泡与捕获演示"><a href="#冒泡与捕获演示" class="headerlink" title="冒泡与捕获演示"></a>冒泡与捕获演示</h3><p>假如有个外层元素称为 <code>box</code>， 它里面包含了一个按钮 <code>btn</code>：</p>
<p><img src="/images/javascript-event-proxy\box.PNG" alt=""></p>
<p>给 <code>box</code> 和 <code>btn</code> 注册点击事件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'box'</span>)</div><div class="line">&#125;)</div><div class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'button'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>点击 <code>btn</code>：</p>
<p><img src="/images/javascript-event-proxy\bubble.gif" alt=""></p>
<p>可以看到，首先打印的是 <code>&#39;button&#39;</code>，接着才是 <code>box</code>. 因为 <code>addEventListener</code> 默认是在冒泡阶段执行回调函数的。这里，最具体的 <code>btn</code> 接受到事件之后，向外层冒泡，<code>box</code> 才能接受到事件。</p>
<p>改一下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'box'</span>)</div><div class="line">&#125;, <span class="literal">true</span>)</div><div class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'button'</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里给 <code>box</code> 的 <code>addEventListener</code> 传入了第三个参数 <code>true</code>, 表示要在捕获阶段处理 <code>box</code> 的点击事件。 </p>
<p><code>addEventListener</code>  第三个参数形参为 <code>useCapture</code>,  表示是否在捕获阶段处理事件，默认为 <code>false</code>.</p>
<p>运行一下：</p>
<p><img src="/images/javascript-event-proxy\capture.gif" alt=""></p>
<p>这样一改，首先打印的就是 <code>&#39;box&#39;</code>, 因为事件具体节点是 <code>btn</code>，而事件要从不太具体的节点，经过捕获阶段，才确定到 <code>btn</code>.  在捕获阶段，外层  <code>box</code> 要比 <code>btn</code> 早接受到事件，所以先执行了 <code>box</code>  捕获阶段的事件处理函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件代理的代码中，注册点击事件的是 <code>table</code> 元素，发生点击事件最具体的节点是 <code>button</code>. 事件在 <code>button</code> 发生后，由于冒泡，会传播到 <code>table</code>， 从而触发 <code>table</code> 上事先注册的回调函数。所以，用事件冒泡实现事件代理，可以只给热心肠同学 <code>table</code> 添加点击事件回调，而不必劳烦表格中的每个 <code>button</code> .</p>
<p>在类似的场景下，可利用事件代理，来减少冗余，节约资源。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/17/JavaScript事件代理/" class="archive-article-date">
  	<time datetime="2019-07-17T05:35:25.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-你好，我是JavaScript的this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/07/你好，我是JavaScript的this/">你好，我是 JavaScript 的this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> JavaScript 有个关键字 <code>this</code>,  时不时冒出来，让你猜一猜，“我到底指向谁？”</p>
<p>这个 <code>this</code> 指向 <code>window</code>, 那个 <code>this</code> 又是刚刚 <code>new</code> 出来的新对象，这里又冒出来一个指向 <code>call</code> 函数的第一个参数的。</p>
<p>到底什么鬼？一团乱麻。</p>
<h2 id="线索"><a href="#线索" class="headerlink" title="线索"></a>线索</h2><p>快刀斩乱麻，这里的快刀同学只会说一句话：”<code>this</code> 指向函数执行的环境对象。”</p>
<h2 id="怎么理解"><a href="#怎么理解" class="headerlink" title="怎么理解"></a>怎么理解</h2><p>带着上面的线索，去几个场景，来看一看，<code>this</code> 在各种情况下，到底指向哪位。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a() <span class="comment">// window</span></div></pre></td></tr></table></figure>
<p>在浏览器中，<code>a</code> 的执行环境即为 <code>window</code>, 所以 <code>this</code> 指向了 <code>window</code>. </p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.b() <span class="comment">// obj</span></div></pre></td></tr></table></figure>
<p>当作为对象的方法时，函数的 <code>this</code> 指向其所属对象。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.age = <span class="number">100</span> </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">GirlFriend</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">18</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> girlFriend = <span class="keyword">new</span> GirlFriend()</div><div class="line"><span class="built_in">console</span>.log(girlFriend.age) <span class="comment">// 18</span></div></pre></td></tr></table></figure>
<p>从 <code>girlFriend.age</code> 为 <code>18</code> 可以看出，以构造函数的形式执行函数时，<code>this</code> 指向其返回的对象。 </p>
<h3 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 <code>this</code> 指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.hello = <span class="string">'Hello, I am window.'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">hello</span>: <span class="string">'Hello, I am obj.'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.hello)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello() <span class="comment">// 'Hello, I am window.'</span></div><div class="line">sayHello.call(obj) <span class="comment">// 'Hello, I am obj.'</span></div><div class="line">sayHello.apply(obj) <span class="comment">// 'Hello, I am obj.'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> hi = sayHello.bind(obj)</div><div class="line">hi() <span class="comment">// 'Hello, I am obj.'</span></div></pre></td></tr></table></figure>
<p><code>call</code> 方法和 <code>apply</code> 方法接收的第一个参数，是一个为函数指定的 <code>this</code>. 上面的代码中，第一次函数调用形式执行 <code>sayHello</code>, <code>this</code> 指向的是 <code>window</code>. 后面的 <code>call</code> 和 <code>apply</code> 指定的 <code>this</code> 是对象 <code>obj</code>,  <code>sayHello</code> 函数执行这两个方法时，<code>this</code> 指向了 <code>obj</code>.</p>
<p><code>bind</code> 方法的第一个参数也是指定的 <code>this</code>, 执行 <code>bind</code> 方法，返回一个拥有指定 <code>this</code> 的函数。上面代码中的 <code>hi</code> 指向一个函数，这个函数是 <code>this</code> 为 <code>obj</code> 的  <code>sayHello</code>.  </p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.hello = <span class="string">'Hello, I am window.'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">hello</span>: <span class="string">'Hello, I am obj.'</span>,</div><div class="line">  <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.hello)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = obj.foo()</div><div class="line">a() <span class="comment">// 'Hello, I am obj.'</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = obj.foo</div><div class="line"><span class="keyword">let</span> c = b()</div><div class="line">c() <span class="comment">// 'Hello, I am window.'</span></div></pre></td></tr></table></figure>
<p>箭头函数没有自己的 <code>this</code>, 当箭头函数内部出现 <code>this</code>, 可将它理解为一个变量——“我没有这个变量，去我的外面一层找一找有没有”。所以，箭头函数的 <code>this</code>, 指向的是定义箭头函数时的外部环境。</p>
<p>上面代码中，对象 <code>obj</code> 的方法 <code>foo</code>, 返回一个箭头函数，该箭头函数打印 <code>this.hello</code>.</p>
<p>变量 <code>a</code> 的值是 <code>obj.foo()</code> 的返回值，即为箭头函数。<code>obj.foo()</code> 是方法调用，此时，<code>foo</code> 的  <code>this</code> 指向的是对象 <code>obj</code>.  而 <code>foo</code> 中的箭头函数用到的 <code>this</code> 是从箭头函数的外部（即 <code>foo</code>）拿到的，也指向 <code>obj</code>.</p>
<p>对象 <code>obj</code> 的 <code>foo</code> 赋值给了变量  <code>b</code>, <code>let b = obj.foo</code> 相当于下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.hello)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来执行 <code>b</code>, 把返回的箭头函数赋值给 <code>c</code>. 此时，执行 <code>b</code> 是一次函数调用，函数 <code>b</code> 的 <code>this</code> 指向的是它的运行环境 <code>window</code>. 箭头函数拿到的 <code>this</code>, 是它外层函数的 <code>this</code>, 也就是 <code>window</code>.  </p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式下，会对函数的 <code>this</code> 指向造成影响。</p>
<p>先上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.hello = <span class="string">'Hello, I am window.'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.hello)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello() <span class="comment">// Uncaught TypeError: Cannot read property 'hello' of undefined.</span></div></pre></td></tr></table></figure>
<p>在严格模式下，函数调用的情景会受到影响。这个时候，函数内的 <code>this</code> 不再指向全局对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>this</code> 指向函数执行的环境对象。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/07/07/你好，我是JavaScript的this/" class="archive-article-date">
  	<time datetime="2019-07-07T05:31:29.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-07-07</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript 函数防抖了解一下" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/29/JavaScript 函数防抖了解一下/">JavaScript 函数防抖了解一下</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>说到防抖，想必多数人首先想到的是相机的防抖。因为我们并不是机器人，所以拿手机拍照的时候，手都会有不易察觉的抖动，这样的抖动会影响相片的质量。手机对这些情况做的一些补偿操作，减小了手抖对成像造成的影响。</p>
<p>我们都知道，JavaScript 是一门编程语言，不是人类也不是机器人。那什么情况下，会产生“抖动”呢？</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>联想一个平平无奇的搜索框，当用户输入的时候，需要实时给出搜索建议。</p>
<p>第一反应肯定是监听输入框的 <code>input</code> 事件，随着内容的变化，发出请求，拉取建议的数据。</p>
<p>如下面的例子（这里 <code>input</code> 被触发时，执行 <code>console.log(&#39;input&#39;)</code>, 并且用 <code>console.log(&#39;fetch&#39;)</code> 代指请求）：</p>
<p><img src="images/javascript-function-debounce/before_debounce.gif" alt=""></p>
<p>可以看到，每一个字符的增减，都会触发请求。</p>
<p>这种情况，就属于“抖动”。</p>
<p>服务器接收到这样的请求，肯定是一脸懵啊，这谁顶得住？</p>
<p>这个时候，就需要像手机相机一样，做一些操作，减少抖动对网络请求的影响，减轻服务器的压力。</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>“抖动”情景下，连续输入，导致发送了多次一样的请求。函数防抖的处理方式是：先规定一个时间段，比如一秒，输入内容触发 <code>input</code> ，一秒之后再发送请求，假如一秒内又产生了新的输入，那么重新计时，点击过后一秒再发送请求。</p>
<p>这样一来，规定时间段内的所有输入，只会产生一次请求。不管打字多快的手速，也战胜不了防抖的函数。</p>
<h2 id="怎么写"><a href="#怎么写" class="headerlink" title="怎么写"></a>怎么写</h2><p>直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, delay = <span class="number">200</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    clearTimeout(timeout)</div><div class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">    &#125;, delay)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>debounce</code> 函数接受一个函数 <code>func</code> 和一个默认为 200 毫秒延迟时间 <code>delay</code> 作为参数。返回一个函数，触发返回的函数，开始计时，<code>delay</code> 毫秒后触发 <code>func</code>, 假如 <code>delay</code> 时间段内，再次触发这个函数，那么重新计时，<code>delay</code> 毫秒后触发 <code>func</code>.</p>
<p><code>debounce</code> 首先声明变量 <code>timeout</code>, 用于存放之后 <code>setTimeout</code> 函数返回的定时器编号。</p>
<p>然后返回一个函数，函数内执行 <code>clearTimeout</code> 来依据先前声明的 <code>timeout</code> 来清除定时器。当然，一开始，传入的 <code>timeout</code> 值为 <code>null</code>, 这时的清除操作忽略不计。</p>
<p>接着，执行 <code>setTimeout</code>, 在至少 <code>delay</code> 规定的毫秒后，将 <code>setTimeout</code> 的回调函数添加到当前事件队列，回调内执行 <code>func</code> 函数。并且把返回的定时器编号赋值给 <code>timeout</code> , 这样，下一次触发  <code>debounce</code> 返回的函数时，就可以清除通过上面的 <code>clearTimeout(timeout)</code> 来清除定时器 。</p>
<p>注意到上面执行 <code>func</code> 用的是 <code>func.apply(this, arguments)</code>, 这样一来，就可以对 <code>debounce</code> 返回的那个函数传递参数，<code>func</code> 执行的时候，再把参数传给 <code>func</code>.</p>
<p>来用一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> suggest = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fetch'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> debounceSuggest = debounce(suggest, <span class="number">500</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> btnSearch = <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>)</div><div class="line">btnSearch.addEventListener(<span class="string">'input'</span>, () =&gt; &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'input'</span>)</div><div class="line">  debounceSuggest()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这里将 <code>suggest</code> 函数传入 <code>debounce</code> 函数，并设置延迟时间为 500 毫秒。 <code>debounce</code> 返回的函数赋给 <code>debounceSuggest</code> , 然后在提交按钮 <code>btnSearch</code> 的 <code>input</code> 事件回调中执行 <code>debounceSuggest</code>.</p>
<p>看下效果：</p>
<p><img src="images/javascript-function-debounce/after_debounce.gif" alt=""></p>
<p> 上图中，一开始的几次连续输入，都不会触发 <code>suggest</code>，打印 <code>fetch</code> ，直到整个单词 <code>helllo</code> 输入完成，才触发了一次 <code>suggest</code>. 接着连续删除，也只触发了一次 <code>suggest</code>.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数的防抖将一定时间内的多次操作，减少为一次，去除冗余，节约资源。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/29/JavaScript 函数防抖了解一下/" class="archive-article-date">
  	<time datetime="2019-06-29T05:04:37.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数防抖/">函数防抖</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-JavaScript节流函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/22/JavaScript节流函数/">JavaScript 节流函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>“节流”，字典上这么解释：</p>
<blockquote>
<p>[throttle]∶节制流入或流出,尤指用节流阀调节。</p>
</blockquote>
<p>那节流函数 (throttle) 就是 “节制流入或流出的函数”，越来越绕了，这是什么鬼？刚开始接触这种名词，反正我是有点摸不着头脑，略抽象，不好理解。</p>
<p>那放下这术语不管，先看看为什么要用它。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>页面事件中，scroll, resize 和 mousemove 事件都有一个共同点，就是会频繁地被触发。举个例子，那 scroll 来看好了。</p>
<p>先写一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">1</span></div><div class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(num++)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里监听了页面的 scroll 事件，当页面滚动时，打印出递增的数字。</p>
<p>下图是运行结果，可以看到，console 里面疯狂输出：</p>
<p><img src="/images/javascript-function-throttle/before_throttle.gif" alt=""></p>
<p>回想一下最常用的 click  事件，是不是老老实实，点一次，执行一次。而 scroll 呢，滚动一小段，好几次就去了。这里还好，不涉及到 DOM 操作，要是在 scroll 事件中处理 DOM 元素，那页面性能肯定受到影响，笔记本风扇说不定随着滚动的页面呼呼作响，或者页面一卡一卡卡出心脏病。</p>
<p>让它消停点的办法，就是让回调少执行几次。提到让疯狂执行的函数少执行几次，限制它的行为，“节流”这个概念是不是隐隐约约出现，不再那么抽象了？就好比把水龙头关小一点，让水慢慢流。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>怎么让这个函数慢慢流呢？</p>
<p>设想一下，页面一直在滚动，根本停不下来。这个时候，回调也一直在触发，噼里啪啦。</p>
<p>和它商量一下： “你能不能隔几秒执行一次?”</p>
<p>“隔几秒？”</p>
<p>“两百毫秒吧。”</p>
<p>节流函数就是给这种高频率触发的函数，规定一个时间间隔，就是这一次执行和下一次执行的时间间隔。</p>
<p>有点像游戏里面的技能冷却时间，放了技能，进入冷却时间，这期间，就算不停地点技能，也放不了，只能等冷却好，再放。</p>
<p>千言万语不如上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, ms = <span class="number">200</span></span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> prev = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</div><div class="line">    <span class="keyword">if</span> (now - prev &gt;= ms) &#123;</div><div class="line">      func()</div><div class="line">      prev = now</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 throttle 函数接受一个函数 <code>func</code> 和一个毫秒数 <code>ms</code> 作为参数，返回一个函数。当返回的函数不停地被触发，只有满足两次触发间隔大于或者等于规定的毫秒数，传入的 <code>func</code> 才执行。</p>
<p>这个间隔是用时间戳来判断的。首先定义变量 <code>prev</code> 记录一个时间，在返回的函数中，取得它执行时的时间戳 <code>now</code>，比较两个时间戳，假如间隔大于规定的毫秒数 <code>ms</code>，就执行传入的 <code>func</code> 函数。</p>
<p>拿上面的例子再举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num = <span class="number">1</span></div><div class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="params">()</span>=&gt;</span> &#123;<span class="built_in">console</span>.log(num++)&#125;, <span class="number">2000</span>)</div></pre></td></tr></table></figure>
<p>这里监听页面滚动事件，每两秒触发一次回调函数。如下所示（没有慢放）：</p>
<p><img src="/images/javascript-function-throttle/after_throttle.gif" alt=""></p>
<p>当然，实际开发中，不会两秒一次这么夸张。这里只是为了更明显地观察到节流函数的作用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>节流函数为高频率触发的回调设定一个执行周期，减少对页面性能的损耗。</p>
<p>可用于 resize, scroll, mousemove 这些事件的回调函数。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/22/JavaScript节流函数/" class="archive-article-date">
  	<time datetime="2019-06-22T05:20:03.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-22</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/节流/">节流</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Vuex基本使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/Vuex基本使用/">Vuex 基本使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>查看<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="external">官方文档</a>可以知道：</p>
<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p>
</blockquote>
<p>怎么理解呢？就拿我两位数的资产的银行卡来说吧，基本的存钱取钱，就是状态管理。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>我们将以一个简单的 Todo 作为例子，来讲解 Vuex 的基本使用。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install vuex --save</div></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>首先需要在项目的 src 目录下，新建一个 Vuex 的目录 store，结构如下：<br><img src="/images/vuex-base/tree.PNG" alt=""></p>
<p>初始化 Vuex：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state.js'</span></div><div class="line"></div><div class="line">Vue.use(Vuex)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>引入 Vuex 是理所当然的，除此之外执行 <code>Vue.use(Vuex)</code> 来全局安装 Vuex. <code>Vuex.Store</code> 即 Vuex 的构造函数，来初始化 Vuex 实例。这里可以看到，我们在 Vuex 构造函数中传入了一个 <code>state</code> 选项，那这个 state 是什么呢？</p>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State 从字面意思理解，就是状态，在 Vuex 里面，什么代表了状态呢？数据。State 是 Vuex 这一状态管理工具的唯一的数据源，所有的数据都储存在里面。<br>State 的写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// state.js</span></div><div class="line"><span class="keyword">const</span> state = &#123;</div><div class="line">  <span class="attr">todoList</span>: <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'todoList'</span>)) || []</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> state</div></pre></td></tr></table></figure>
<p>这里声明了一个 state, 里面有一个 todoList 的字段，todoList 的数据是去 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage" target="_blank" rel="external">localStorage</a> 里面拿的，如果没有，就是一个空数组。<br>好了，现在我们的状态已经有了，接下来就是要在组件里面，获取这个 state, 也就是让我们的组件拿到这里的数据。</p>
<h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getter, 顾名思义，就是一个“取”的操作，来拿 state 里面的数据。Getter 的写法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getters.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> todoList = <span class="function"><span class="params">state</span> =&gt;</span> state.todoList</div></pre></td></tr></table></figure>
<p>这里声明并输出了一个 <code>todoList</code> 函数，函数的参数是 <code>state</code>, 返回值  <code>state.todoList</code>.<br>Getter 函数接受 state 作为它的第一个参数。这里我们就取到了上一节 state 里面的 todoList.<br>在需要 todoList 数据的组件当中，可以利用 <code>mapGetters</code> 将数据映射到计算属性。写法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">export <span class="keyword">default</span> &#123;</div><div class="line">  ...</div><div class="line">  computed: &#123;</div><div class="line">    ...mapGetters([</div><div class="line">      <span class="string">'todoList'</span></div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的时候，和普通的计算属性别无二致:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"todo-list"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in todoList"</span> <span class="attr">:key</span>=<span class="string">"index"</span> <span class="attr">class</span>=<span class="string">"todo-item"</span> &gt;</span></div><div class="line">      ...</div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样，<code>todoList</code> 就被渲染到了页面中：<br><img src="/images/vuex-base/getter-render.PNG" alt="todoList"></p>
<p>当然，不管是标记一个事项为完成，还是添加删除事项，todoList 都会产生变化，也就是 state 会变化。那我们怎么去改变 state 呢？这就需要 mutation 的帮助 。</p>
<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>Mutation 是 Vuex 当中改变 state 唯一的方法。Mutation 使用与事件处理函数非常相似，都具有类型和回调函数。<br>这里把 mutation 比作事件，首先来规定“事件类型”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutation-types.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_TODO_LIST = <span class="string">'SET_TODO_LIST'</span></div></pre></td></tr></table></figure>
<p>这里规定了一个 <code>SET_TODO_LIST</code> 的类型。<br>类型是不可变的，所以我们将其声明为常量。<br>然后再来写“事件”的“回调”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mutations.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'./mutation-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mutations = &#123;</div><div class="line">  [types.SET_TODO_LIST] (state, todoList) &#123;</div><div class="line">    state.todoList = todoList</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> mutations</div></pre></td></tr></table></figure>
<p>可以看到， mutations 是一个对象，一个“事件类型”就对应可一个处理函数。处理函数接受 <code>state</code> 作为它的第一个参数，第二个参数是额外的，一般称之为“荷载 (payload) ”。<br>这里我们的荷载是一个 <code>todoList</code>，这个处理函数将 <code>state</code> 原来的 <code>todoList</code> 改为传入的荷载。<br>要使用 mutations，在 Vuex 的构造函数中，就要将 <code>mutations</code> 选项加进去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state.js'</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></div><div class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></div><div class="line"><span class="keyword">import</span> createLogger <span class="keyword">from</span> <span class="string">'vuex/dist/logger'</span></div><div class="line"></div><div class="line">Vue.use(Vuex)</div><div class="line"></div><div class="line"><span class="keyword">const</span> debug = process.env.NODE_ENV !== <span class="string">'production'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</div><div class="line">  state,</div><div class="line">  getters,</div><div class="line">  mutations,</div><div class="line">  <span class="attr">plugins</span>: debug ? [createLogger()] : []</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>现在，构造函数中已经传入了 <code>mutations</code>，接下来，就是在组件中使用 mutations（这里的第四个选项 <code>plugins</code> 并不影响 mutation 的功能，用途是在控制台打印 Vuex 操作的信息）.</p>
<p>TodoList 组件中，我们在“添加事项”这一动作提交 mutation, 改变 state.<br>组件内的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// todo-list.vue</span></div><div class="line">  <span class="keyword">import</span> &#123; mapGetters, mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></div><div class="line"></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    ...</div><div class="line">    methods: &#123;</div><div class="line">      ...</div><div class="line">      addItem () &#123;</div><div class="line">        <span class="keyword">let</span> itemText  = <span class="built_in">window</span>.prompt(<span class="string">'请输入要添加的事项：'</span>)</div><div class="line">        <span class="keyword">if</span> (itemText) &#123;</div><div class="line">          <span class="keyword">let</span> list = <span class="keyword">this</span>.todoList.slice();</div><div class="line">          list.push(&#123;</div><div class="line">            <span class="attr">text</span>: itemText,</div><div class="line">            <span class="attr">done</span>: <span class="literal">false</span>,</div><div class="line">            <span class="attr">checked</span>: <span class="literal">false</span></div><div class="line">          &#125;)</div><div class="line">          <span class="keyword">this</span>.setTodoList(list)</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      ...</div><div class="line">      ...mapMutations(&#123;</div><div class="line">        <span class="attr">setTodoList</span>: <span class="string">'SET_TODO_LIST'</span></div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>接下来就去 todo 里面添加一个条目。如图，添加了一个 coding 事项：<br><img src="/images/vuex-base/mutation-interface.PNG" alt="添加事项"></p>
<p>可在 vue 的 devtool 观察到如下结果：<br><img src="/images/vuex-base/mutations-vue-devtool.PNG" alt=""></p>
<p>可以看到 mutation 的 payload 以及 type 信息。<br>再来观察 Vuex 的 createLogger 插件在控制台输出的信息：<br><img src="/images/vuex-base/mutations-console.PNG" alt=""><br>可以看到，这里进行了一次  <code>SET_TODO_LIST</code> 的 mutation 操作。从 <code>prev state</code>可以知道 ，操作前， <code>todoList</code> 只有三个条目。进行 <code>SET_TODO_LIST</code> 操作时，传入的荷载为四个条目的 todoList。操作后，观察 <code>next state</code> 可知，操作后的 <code>todoList</code> 已经有四个事项。<br>在线上的 <a href="https://zhongyangxun.github.io/vuex-demo/dist/" target="_blank" rel="external">Demo</a><br> 中可打开控制台，添加或者删除条目，观察 Vuex 的状态变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里用一个 todo 的例子，简单介绍了 Vuex 基本的  getters 和 mutatiosn 操作，更多的细节，可参考<a href="https://vuex.vuejs.org/zh/" target="_blank" rel="external">官方文档</a><br>。<br>Vuex 的应用场景是，当 n 多个组件之间的相互通信让人眼花缭乱，那么借助 Vuex 保存多个组件共享的状态，只需操作 state，就能在组件之间同步状态。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2019/06/17/Vuex基本使用/" class="archive-article-date">
  	<time datetime="2019-06-17T05:40:05.000Z" itemprop="datePublished"><i class="icon-clock"></i>2019-06-17</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vuex/">Vuex</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Vim-基本操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/29/Vim-基本操作/">Vim 基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>初次接触到 Vim 是在 Git 命令行中。改写提交的 <code>git commit --amend</code> 命令执行后，需要按下 <code>i</code> 才能修改 commit 信息，修改之后需要按下 <code>Esc</code> 然后输入 <code>:wq</code> 来保存修改并退出，若不想保存修改可输入 <code>:q</code> 退出。<br>最近的工作中涉及到在虚拟机里面编辑简单的文本，自然要用到 Vim，可还不知道怎么在 Vim 里面进行复制粘贴的基本操作呢，于是搜索一番，并记录下一些基本的操作。</p>
<h3 id="新建-打开文件"><a href="#新建-打开文件" class="headerlink" title="新建/打开文件"></a>新建/打开文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$vim filename</div></pre></td></tr></table></figure>
<p>该命令可打开文件，如果文件不存在，则新建一个文件。</p>
<h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><p><code>i</code> 进入 Insert 模式，终端窗口下方可见 <code>Insert</code> 字样。此时可进行文件的编辑。<br>Insert 模式下，按下 <code>Esc</code> 退出该模式，输入 <code>:q</code> 退出，<code>:q!</code> 退出并忽略修改，<code>:wq</code> 保存并退出。</p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>键盘上的上下左右即可实现光标移动，此外以下按键也可移动光标：</p>
<ul>
<li><code>h</code> 向左</li>
<li><code>j</code> 向下</li>
<li><code>k</code> 向上</li>
<li><code>l</code> 向右</li>
</ul>
<h3 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h3><p>首先按下 <code>v</code> 进入 Vim 的 Visual 模式，移动光标可选择文本。<br><code>y</code> 可将选中的文本复制到剪贴板，<code>d</code> 则是剪切。<br><code>p</code> 可实现粘贴。</p>
<h3 id="查找-替换"><a href="#查找-替换" class="headerlink" title="查找/替换"></a>查找/替换</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li><code>:/cat</code> 向下查找cat</li>
<li><code>?/cat</code> 向上查找cat</li>
<li><code>n</code> 下一个匹配</li>
<li><code>N</code> 上一个匹配<h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4></li>
<li><code>:s/cat/dog</code> 替换当前行的第一个 cat 为 dog</li>
<li><code>:s/cat/dog/g</code> 替换当前行所有 cat 为 dog</li>
<li><code>:%s/cat/dog</code> 替换所有行第一个 cat 为 dog</li>
<li><code>%s/cat/dog/g</code> 替换所有 cat 为 dog</li>
</ul>
<h3 id="行跳转-翻页"><a href="#行跳转-翻页" class="headerlink" title="行跳转/翻页"></a>行跳转/翻页</h3><ul>
<li><code>:n</code> 跳转到第 n 行</li>
<li><code>Ctrl</code> + <code>f</code> (forward)下一页</li>
<li><code>Ctrl</code> + <code>b</code> (backward) 上一页<h3 id="删除-插入行"><a href="#删除-插入行" class="headerlink" title="删除/插入行"></a>删除/插入行</h3></li>
<li><code>dd</code> 删除当前行</li>
<li><code>o</code> 向下插入一行</li>
<li><code>O</code> 向上插入一行</li>
</ul>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul>
<li><code>u</code> (undo) 撤销操作</li>
<li><code>Ctrl</code> + <code>r</code>（redo) 恢复操作</li>
</ul>
<p>以上即是 Vim 的一些操作，可应付简单的文本处理。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2018/09/29/Vim-基本操作/" class="archive-article-date">
  	<time datetime="2018-09-29T13:05:12.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-09-29</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vim/">vim</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-Stylus基本使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/09/Stylus基本使用/">Stylus基本使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学习一个Vue.js项目的过程中，注意到源码中样式的部分并没有用熟悉的.css样式文件，而是发现了代码长得和css相像的.styl文件。这个.styl以前没见过啊，你是谁？于是开始一顿搜索。</p>
<p>发现文件后缀是.styl的这个哥们儿学名叫stylus，是css的预处理框架。</p>
<p>css预处理，顾名思义，预先处理css。那stylus咋预先处理呢？stylus给css添加了可编程的特性，也就是说，在stylus中可以使用变量、函数、判断、循环一系列css没有的东西来编写样式文件，执行这一套骚操作之后，这个文件可编译成css文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，安装stylus（确保之前已经安装nodejs）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install stylus</div></pre></td></tr></table></figure></p>
<p>安装之后，运行<code>stylus -h</code> 可查看帮助。<br>运行<code>stylus example.styl</code>可将example.styl文件编译成example.css文件。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>一段简单的stylus代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$background</span>-<span class="attribute">color</span> = lightblue</div><div class="line"><span class="function"><span class="title">add</span><span class="params">(a, b = a)</span></span></div><div class="line">	<span class="selector-tag">a</span> = unit(<span class="selector-tag">a</span>, px)</div><div class="line">	<span class="selector-tag">b</span> = unit(<span class="selector-tag">b</span>, px)</div><div class="line">	<span class="selector-tag">a</span> + <span class="selector-tag">b</span></div><div class="line"></div><div class="line"><span class="selector-class">.list-item</span></div><div class="line"><span class="selector-class">.text-box</span></div><div class="line">	<span class="selector-tag">span</span></div><div class="line">		<span class="attribute">background-color</span>: <span class="variable">$background</span>-color</div><div class="line">		<span class="attribute">margin</span>: add(<span class="number">10</span>)</div><div class="line">		<span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">	&amp;:hover</div><div class="line">		<span class="attribute">background-color</span>: powderblue</div></pre></td></tr></table></figure></p>
<p>编译后生成的css代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-item</span> <span class="selector-tag">span</span>,</div><div class="line"><span class="selector-class">.text-box</span> <span class="selector-tag">span</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#add8e6</span>;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">15px</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.list-item</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-class">.text-box</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#b0e0e6</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此我们看到了stylus代码以及由它编译而成的css代码,下面来一步一步看一看为啥编译成这样。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$background</span>-<span class="attribute">color</span> = lightblue</div></pre></td></tr></table></figure>
<p>上面的代码声明了变量<code>$background-color</code>,并为其赋值<code>lightblue</code>。<br>声明之后，就可以使用这个变量了：<br><figure class="highlight styl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span></div><div class="line">	<span class="attribute">background-color</span>: <span class="variable">$background</span>-color</div></pre></td></tr></table></figure></p>
<p>翻译成css就是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span>&#123;</div><div class="line">    <span class="attribute">background-color</span>: lightblue;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">add</span><span class="params">(a, b = a)</span></span></div><div class="line">	<span class="selector-tag">a</span> = unit(<span class="selector-tag">a</span>, px)</div><div class="line">	<span class="selector-tag">b</span> = unit(<span class="selector-tag">b</span>, px)</div><div class="line">	<span class="selector-tag">a</span> + b</div></pre></td></tr></table></figure>
<p>代码声明了函数<code>add</code>,<code>add</code>接受两个参数<code>a</code>和<code>b</code>，其中<code>b</code>的默认值是<code>a</code>。<br><code>add</code>中调用了stylus的内置函数<code>unit</code>，此处，<code>unit</code>函数为<code>a</code>和<code>b</code>赋予了单位<code>px</code>。<br>最后将<code>a</code>和<code>b</code>相加，并返回结果，是的，你没有看错，没有<code>return</code>，但是返回了结果。<br><code>return</code>居然是可以省略的，很任性了。</p>
<p>函数调用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span></div><div class="line">    <span class="attribute">margin</span>: add(<span class="number">10</span>)</div><div class="line">    <span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</div></pre></td></tr></table></figure></p>
<p>翻译成css就是：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">span</span>&#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-item</span></div><div class="line"><span class="selector-class">.text-box</span></div><div class="line">	<span class="selector-tag">span</span></div><div class="line">		<span class="attribute">background-color</span>: <span class="variable">$background</span>-color</div><div class="line">		<span class="attribute">margin</span>: add(<span class="number">10</span>)</div><div class="line">		<span class="attribute">padding</span>: add(<span class="number">10</span>, <span class="number">5</span>)</div><div class="line">	&amp;:hover</div><div class="line">		<span class="attribute">background-color</span>: powderblue</div></pre></td></tr></table></figure>
<p>这一段是与css代码长得最像的了，虽说最为相像，可有些差别还是一眼就能看出的。<br>比如没有了css的花括号，没有了css的分号，却多了一些奇奇怪怪的缩进，还有那个<code>&amp;</code>是什么鬼？还<code>&amp;:hover</code>???<br>预知后事如何，这次接着分解。</p>
<p>先说符号，这里提到的花括号和分号在stylus中是可以省略的，不仅如此，冒号也是可以省略的，<code>color: powderblue</code>你可以写成<code>color powderblue</code>,没有问题。</p>
<p>再说缩进，先提出两个有缩进关系的选择器，上面代码片段第二行的<code>.text-box</code>和第三行的<code>span</code>，其实很容易理解，这哥俩写到css里面是这样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.text-box span&#123; ... &#125;</div></pre></td></tr></table></figure></p>
<p>即<code>span</code>是<code>.text-box</code>的子选择器，stylus中以缩进表示这种关系，更加清晰明了，好看。</p>
<p>还有<code>&amp;</code>，这是个新鲜东西。它是父级的引用，还是来看代码。</p>
<p>stylus这样写:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-item</span></div><div class="line"><span class="selector-class">.text-box</span></div><div class="line">	&amp;:hover</div><div class="line">		<span class="attribute">background-color</span>: powderblue</div></pre></td></tr></table></figure></p>
<p>翻译成css是这样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.list-item</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-class">.text-box</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#b0e0e6</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信代码中已经能很明确地体现出<code>&amp;</code>父级引用的角色了。<br>同时，我们也不难看出，<code>.list-item</code>和<code>.text-box</code>这两个同一级的选择器在stylus中是可以换行写的，只要保证缩进相同，它们就属于同一级的选择器。当然，沿用css的方式，将同一级的选择器用逗号分隔开在stylus中也是可以的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面就是stylus的基本使用，普遍情况可以用上。<br>全面的stylus知识可以参考<a href="http://stylus-lang.com/" target="_blank" rel="external">官方文档</a>，或者张鑫旭翻译的<a href="http://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="external">中文文档 </a>。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2018/03/09/Stylus基本使用/" class="archive-article-date">
  	<time datetime="2018-03-09T06:55:53.000Z" itemprop="datePublished"><i class="icon-clock"></i>2018-03-09</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css/">css</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stylus/">stylus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/样式/">样式</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-相对路径与绝对路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/21/相对路径与绝对路径/">相对路径与绝对路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于相对路径和绝对路径的了解一直以来都不甚清晰，只知道从根目录开始的是绝对路径，相对于当前文件的是相对路径。</p>
<p>之前写代码所用的URL是相对路径，类似于这种：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">background-image:url(img/beatles.jpg)</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery.min.js"</span> &gt;</span><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml"></span></span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/blur.jpg"</span> &gt;</span></div></pre></td></tr></table></figure>
<p>直到开始学习Vue.js，在代码里出现的路径如 :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></div></pre></td></tr></table></figure>
<p>就有点懵，<code>App</code>前面的那个<code>./</code>是什么鬼？<br>完全不知道是为什么要这么写，才想起来去Google。</p>
<p>关于相对路径和绝对路径的规则，总结如下：</p>
<ol>
<li>绝对路径是从根目录一直到目的文件的完整路径</li>
<li>相对路径是一部分的路径，其表示的位置取决于特定的前缀</li>
</ol>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>种类</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>表示当前目录</td>
<td>相对路径</td>
</tr>
<tr>
<td>没有前缀</td>
<td>当前目录</td>
<td>相对路径</td>
</tr>
<tr>
<td><code>..</code></td>
<td>表示上一层目录</td>
<td>相对路径</td>
</tr>
<tr>
<td><code>/</code></td>
<td>代表根目录</td>
<td>绝对路径</td>
</tr>
<tr>
<td><code>D:/</code></td>
<td>当然是根目录</td>
<td>绝对路径</td>
</tr>
</tbody>
</table>
<p><em>注：在D盘里上面的 <code>/</code>等同于 <code>D:/</code></em></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/08/21/相对路径与绝对路径/" class="archive-article-date">
  	<time datetime="2017-08-21T15:35:31.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-08-21</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-js/">vue.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/相对路径/">相对路径</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/绝对路径/">绝对路径</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 菲利普马洛
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				<a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Vuex/" style="font-size: 10px;">Vuex</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/stylus/" style="font-size: 10px;">stylus</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/tags/作用域/" style="font-size: 10px;">作用域</a> <a href="/tags/函数防抖/" style="font-size: 10px;">函数防抖</a> <a href="/tags/样式/" style="font-size: 10px;">样式</a> <a href="/tags/相对路径/" style="font-size: 10px;">相对路径</a> <a href="/tags/绝对路径/" style="font-size: 10px;">绝对路径</a> <a href="/tags/节流/" style="font-size: 10px;">节流</a>
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>